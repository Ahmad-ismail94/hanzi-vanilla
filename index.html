<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hanzi Trainer — vanilla PWA (Offline)</title>
    <link rel="manifest" href="manifest.webmanifest">
    <link rel="apple-touch-icon" href="icons/icon-192x192.png">
    <style>
        body { font-family: sans-serif; display: flex; }
        .main { flex: 1; padding: 20px; }
        .sidebar { width: 200px; border-left: 1px solid #ccc; padding: 20px; }
        .character { text-align: center; }
        h1 { font-size: 100px; margin: 0; }
        .pinyin { display: flex; justify-content: center; align-items: center; }
        .pinyin span { margin-right: 10px; }
        .mode { display: flex; justify-content: center; margin: 20px 0; }
        .mode button { margin: 0 5px; }
        .mode button.active { background: lightblue; }
        .srs { display: flex; justify-content: center; margin: 20px 0; }
        .srs button { margin: 0 5px; }
        .actions { display: flex; justify-content: center; margin: 20px 0; }
        #word-list { list-style: none; padding: 0; }
        #word-list li { cursor: pointer; padding: 5px; }
        #word-list li:active { background: gray; }
        #word-list li.selected { background: lightblue; }
        .badge { font-size: small; color: green; margin-left: 5px; }
        canvas { border: 1px solid #000; display: block; margin: 20px auto; touch-action: none; }
    </style>
</head>
<body>
    <div class="main">
        <div class="character">
            <h1 id="hanzi"></h1>
            <div class="pinyin">
                <span id="pinyin"></span>
                <button id="play">▶︎</button>
                <button id="slow">⟲0.85×</button>
                <button id="replay">↺</button>
            </div>
            <span id="english"></span>
        </div>
        <canvas id="canvas" width="256" height="256"></canvas>
        <div class="mode">
            <button id="guided" class="active">Guided</button>
            <button id="recall">Recall</button>
            <label>Strictness: flex</label>
        </div>
        <div class="srs">
            <button>Again</button>
            <button>Hard</button>
            <button>Good</button>
            <button>Easy</button>
        </div>
        <div class="actions">
            <button id="export">Export JSON</button>
            <input type="file" id="import" style="display:none"/>
            <label for="import"> Import JSON</label>
        </div>
        <div id="result">Result: </div>
    </div>
    <div class="sidebar">
        <h2>Words</h2>
        <ul id="word-list"></ul>
    </div>
    <script>
        // Data
        let words = [];
        let strokesData = {};
        let currentWord = null;
        let currentStrokes = [];
        let strokeIndex = 0;
        let mode = 'guided';
        let progress = JSON.parse(localStorage.getItem('hanzi-progress')) || {};
        let voices = [];
        let chineseVoice = null;
        let lastUtterance = null;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let drawing = false;
        let currentPath = [];

        // Load data
        async function loadData() {
            const wordsRes = await fetch('data/words-50.json');
            words = await wordsRes.json();
            const strokesRes = await fetch('data/strokes/characters.json');
            strokesData = await strokesRes.json();
            populateWordList();
        }

        // Populate word list
        function populateWordList() {
            const ul = document.getElementById('word-list');
            ul.innerHTML = '';
            words.forEach(w => {
                const li = document.createElement('li');
                li.textContent = w.hanzi + ' (' + w.pinyin + ')';
                if (progress[w.hanzi] > 0) {
                    const badge = document.createElement('span');
                    badge.className = 'badge';
                    badge.textContent = '✓' + progress[w.hanzi];
                    li.appendChild(badge);
                }
                li.addEventListener('click', () => selectWord(w));
                ul.appendChild(li);
            });
        }

        // Select word
        function selectWord(word) {
            currentWord = word;
            document.getElementById('hanzi').textContent = word.hanzi;
            document.getElementById('pinyin').textContent = word.pinyin;
            document.getElementById('english').textContent = word.english;
            // Highlight selected
            const lis = document.querySelectorAll('#word-list li');
            lis.forEach(li => li.classList.remove('selected'));
            const selectedLi = Array.from(lis).find(li => li.textContent.startsWith(word.hanzi));
            if (selectedLi) selectedLi.classList.add('selected');
            // Load strokes
            currentStrokes = [];
            for (let char of word.hanzi) {
                if (strokesData[char]) {
                    currentStrokes = currentStrokes.concat(strokesData[char]);
                }
            }
            strokeIndex = 0;
            clearCanvas();
            drawCurrentStrokeGuide();
        }

        // Canvas events
        canvas.addEventListener('pointerdown', e => {
            drawing = true;
            currentPath = [];
            const rect = canvas.getBoundingClientRect();
            currentPath.push({x: e.clientX - rect.left, y: e.clientY - rect.top});
            ctx.beginPath();
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
        });

        canvas.addEventListener('pointermove', e => {
            if (!drawing) return;
            const rect = canvas.getBoundingClientRect();
            const point = {x: e.clientX - rect.left, y: e.clientY - rect.top};
            currentPath.push(point);
            ctx.lineTo(point.x, point.y);
            ctx.stroke();
        });

        canvas.addEventListener('pointerup', () => {
            drawing = false;
            if (currentPath.length < 2) return;
            processStroke();
        });

        // Clear canvas
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // Draw guide for current stroke in guided mode
        function drawCurrentStrokeGuide() {
            if (mode !== 'guided' || strokeIndex >= currentStrokes.length) return;
            const stroke = currentStrokes[strokeIndex];
            // Assume strokes are 0-1024, scale to 256
            const scale = 256 / 1024;
            ctx.strokeStyle = '#ccc';
            ctx.beginPath();
            ctx.moveTo(stroke[0].x * scale, stroke[0].y * scale);
            for (let i = 1; i < stroke.length; i++) {
                ctx.lineTo(stroke[i].x * scale, stroke[i].y * scale);
            }
            ctx.stroke();
            // Start/end points
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(stroke[0].x * scale, stroke[0].y * scale, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = 'blue';
            ctx.beginPath();
            ctx.arc(stroke[stroke.length - 1].x * scale, stroke[stroke.length - 1].y * scale, 5, 0, 2 * Math.PI);
            ctx.fill();
        }

        // Process drawn stroke
        function processStroke() {
            if (strokeIndex >= currentStrokes.length) return;
            let refStroke = scaleStroke(currentStrokes[strokeIndex]);
            let drawn = simplifyPath(currentPath); // Simplify if needed
            let dist = frechetDistance(drawn, refStroke);
            let revRef = refStroke.slice().reverse();
            let revDist = frechetDistance(drawn, revRef);
            let minDist = Math.min(dist, revDist);
            const threshold = mode === 'guided' ? 20 * 1.5 : 20; // Example threshold in pixels, adjust as needed
            const resultDiv = document.getElementById('result');
            if (minDist <= threshold) {
                resultDiv.textContent = 'Result: OK';
                // Draw reference in green
                ctx.strokeStyle = 'green';
                ctx.beginPath();
                const useRef = dist <= revDist ? refStroke : revRef;
                ctx.moveTo(useRef[0].x, useRef[0].y);
                for (let i = 1; i < useRef.length; i++) {
                    ctx.lineTo(useRef[i].x, useRef[i].y);
                }
                ctx.stroke();
                // Advance
                strokeIndex++;
                setTimeout(() => {
                    clearCanvas();
                    drawCurrentStrokeGuide();
                }, 1000); // Short delay to see green
                if (strokeIndex >= currentStrokes.length) {
                    completeWord();
                }
            } else {
                resultDiv.textContent = 'Result: Close, try again';
                // Clear drawn path? Or keep
                setTimeout(clearCanvas, 1000);
                drawCurrentStrokeGuide();
            }
        }

        // Scale stroke to canvas size
        function scaleStroke(stroke) {
            const scale = 256 / 1024;
            return stroke.map(p => ({x: p.x * scale, y: p.y * scale}));
        }

        // Simplify path (optional, reduce points)
        function simplifyPath(path) {
            return path; // Implement Douglas-Peucker if needed
        }

        // Frechet distance
        function frechetDistance(p, q) {
            const ca = Array.from({length: p.length}, () => Array(q.length).fill(-1));
            function dist(a, b) {
                return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
            }
            function c(i, j) {
                if (ca[i][j] > -1) return ca[i][j];
                if (i === 0 && j === 0) {
                    ca[0][0] = dist(p[0], q[0]);
                    return ca[0][0];
                }
                let min = Infinity;
                if (i > 0) min = Math.min(min, c(i - 1, j));
                if (j > 0) min = Math.min(min, c(i, j - 1));
                if (i > 0 && j > 0) min = Math.min(min, c(i - 1, j - 1));
                ca[i][j] = Math.max(min, dist(p[i], q[j]));
                return ca[i][j];
            }
            return c(p.length - 1, q.length - 1);
        }

        // Complete word
        function completeWord() {
            document.getElementById('result').textContent = 'Result: Completed ✓';
            progress[currentWord.hanzi] = (progress[currentWord.hanzi] || 0) + 1;
            localStorage.setItem('hanzi-progress', JSON.stringify(progress));
            populateWordList(); // Update badge
        }

        // Mode switch
        document.getElementById('guided').addEventListener('click', () => {
            mode = 'guided';
            document.getElementById('guided').classList.add('active');
            document.getElementById('recall').classList.remove('active');
            clearCanvas();
            drawCurrentStrokeGuide();
        });
        document.getElementById('recall').addEventListener('click', () => {
            mode = 'recall';
            document.getElementById('recall').classList.add('active');
            document.getElementById('guided').classList.remove('active');
            clearCanvas();
            // No guide in recall
        });

        // TTS
        speechSynthesis.onvoiceschanged = () => {
            voices = speechSynthesis.getVoices();
            chineseVoice = voices.find(v => v.lang.startsWith('zh-'));
        };

        function speak(text, rate = 1) {
            if (!voices.length) {
                speechSynthesis.getVoices(); // Trigger load
            }
            const utt = new SpeechSynthesisUtterance(text);
            utt.voice = chineseVoice || voices[0];
            utt.lang = 'zh-CN';
            utt.rate = rate;
            speechSynthesis.speak(utt);
            lastUtterance = utt;
            return utt;
        }

        document.getElementById('play').addEventListener('click', () => {
            if (currentWord) speak(currentWord.hanzi);
        });
        document.getElementById('slow').addEventListener('click', () => {
            if (currentWord) speak(currentWord.hanzi, 0.85);
        });
        document.getElementById('replay').addEventListener('click', () => {
            if (lastUtterance) {
                const replayUtt = new SpeechSynthesisUtterance(lastUtterance.text);
                replayUtt.voice = lastUtterance.voice;
                replayUtt.lang = lastUtterance.lang;
                replayUtt.rate = lastUtterance.rate;
                speechSynthesis.speak(replayUtt);
            }
        });

        // Export/Import - assuming for SRS, but minimal
        document.getElementById('export').addEventListener('click', () => {
            const blob = new Blob([JSON.stringify(progress)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'hanzi-progress.json';
            a.click();
        });
        document.getElementById('import').addEventListener('change', e => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = ev => {
                progress = JSON.parse(ev.target.result);
                localStorage.setItem('hanzi-progress', JSON.stringify(progress));
                populateWordList();
            };
            reader.readAsText(file);
        });

        // SRS buttons - placeholder, as not specified
        document.querySelectorAll('.srs button').forEach(btn => {
            btn.addEventListener('click', () => {
                // Implement SRS logic if needed
                console.log(btn.textContent + ' pressed');
            });
        });

        // PWA registration
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js');
        }

        loadData();
    </script>
</body>
</html>
